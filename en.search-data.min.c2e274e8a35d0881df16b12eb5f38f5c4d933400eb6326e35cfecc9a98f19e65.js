'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/about/','title':"About Me",'content':"About me Who am I? I\u0026rsquo;m Hamza, a graduate student in aerospace engineering. I\u0026rsquo;m passionate about all things that fly, especially the part that goes about controling those things\u0026mdash;control theory.\nI like tinkering around with hardware and code to see if my ideas are actually capable of holding water in reality (check out the projects tab for more on that). That\u0026rsquo;s where I feel my drive lies\u0026mdash;bringing theory and practice together, regardless of what their original applications may be.\nWhen I\u0026rsquo;m not doing research, I like to hike and work on my coding projects, as well as playing tennis or practicing jiujitsu.\n Fig.: Me   "});index.add({'id':1,'href':'/docs/cv/','title':"Curriculum Vitae",'content':"Curriculum Vitae  \nBio  Aerospace engineering PhD candidate conducting research in adaptive control theory and robust safety-critical control.\n Academics University of Illinois at Urbana-Champaign \u0026mdash; PhD Candidate August 2020\u0026mdash; in Urbana-Champaign, IL \nJointly supervised PhD program in Aerospace Engineering and Mechanical Science and Engineering, focusing on control theory, especially regarding safety-critical control in environments with limited prior knowledge, as well as biomedical applications.\nTeaching Assistantships  ME 498/598: Advanced Computer Control (Fall 2020):  A course aimed at providing students a foundation in modern real-time-computable control design through progression from basic theory to advanced control algorithms that have proven successful in applications. Both discrete time (DT) and (CT) formats are employed and linked through discrete-continuous (sampled-data) concepts. The laboratory part of the course provides exposure to\n the elements of AI and machine learning proven useful in enhancing these algorithms, the related Matlab toolboxes and algorithm implementations from the ground up, implementation of these algorithms on modern computing platforms (GPUs and FPGAs), and applications in aerospace, power generation, manufacturing, and other areas.  I was responsible for grading homeworks, lab reports, and the final project (a project where students independently explore an robust adaptive control concept and apply it to their research). I was also responsible for developing the lab materials (a rigorous exploration of the theory, followed by interactive code examples and exercises related to real-life applications), in addition to and teaching lab lectures and having office hours.\nDelft University of Technology \u0026mdash; Undergraduate Aerospace Engineering September 2017\u0026ndash;July 2020 (3 years) in Delft, The Netherlands \nBachelor\u0026rsquo;s degree in Aerospace Engineering, with a graduation thesis on a cost-effective civilian aircraft flight simulator for upset prevention and recovery training (UPRT).\nDelft University of Technology \u0026mdash; Honours Programme Delft Bachelor Student September 2018\u0026ndash;July 2020 (2 years) in Delft, The Netherlands \nProgram for honors students, including a research segment (14 ECTS) and an interdisciplinary segment (6 ECTS). The research is on a range-restricted guidance law for the optimal ascent of experimental rockets. The interdisciplinary segment consisted on a course on Global Development Engineering, and a summer school at CERN on innovative engineering and design thinking.\nUniversity of Illinois at Urbana-Champaign \u0026mdash; Exchange Student August 2019\u0026ndash;January 2020 (5 months) in Urbana-Champaign, IL \nSemester-long exchange at the University of Illinois, focusing on hypersonic aerodynamics, real-time computer control and machine learning. Additionally working on an independent study on in-flight change-conscious estimation and prediction of environmental parameters in aerospace vehicles.\n Internships CERN \u0026mdash; CERN Honours Programme Summer School July 2019 (1 month) in Meyrin, Canton of Geneva, Switzerland \nA three week summer course at CERN IdeaSquare in Geneva in which students work in multidisciplinary teams to investigate a novel technology to find innovative applications which solve societal problems.\nEuropean Space Agency - ESA \u0026mdash; Introduction to Space Law Training Course June 2019 (1 week) in Redu, Belgium \nA week-long intensive training course on the concept of Space Law, including its implementation within the European space program and national law. Among the speakers were experts from ESA, as well as national officials from space offices in Europe and the Secretary-General of the United Nations Committee on the Peaceful Uses of Outer Space. The course was wrapped up with a model United Nations General-Assembly meeting.\n Extracurricular activities The Illinois Space Society \u0026mdash; Technical Manager September 2019\u0026ndash;January 2020 (5 months) in Urbana-Champaign, IL \nFull design and engineering of a sounding rocket and aerially-deployed quadcopter payload as the Technical Manager for the University of Illinois at Urbana-Champaign\u0026rsquo;s NASA University Student Launch Initiative team.\nThis entails managing a team of students to develop an in-house project with limited funds. In addition to production, careful design and simulations are an integral part of the process, and much efforts are invested in the study of highfidelity simulation methods for trajectory, flight loads, and stability assessment.\nFinally, advanced robust autonomous control systems design for a quadcopter that can retrieve a ground sample are a unique aspect of the project. Here, I have introduced team members to safety critical programming in C++, and have lead the groundwork to informed system design, as well as controller design and communications protocols between ground and the vehicle.\nDelft Aerospace Rocket Engineering \u0026mdash; Flight Simulations Engineer November 2018\u0026ndash;August 2019 (10 months) in Delft, The Netherlands \nResponsible for creating a novel sounding rocket flight simulation code from scratch. This code is object oriented and written in C++, with Python bindings for easy interfacing. Aerodynamics and environmental effects (atmosphere and gravity) are included in a six degrees-of-freedom kinematics model, with variable geometry, engines and stage separation and recovery systems. Apart from apogee and expected landing location prediction, vehicle-environment interaction is also modeled.\nTV Tokyo \u0026mdash; Participation in a program of TV Tokyo December 2016, August 2017 in Japan\nParticipation in an educational Japanese TV-program by TV Tokyo called \u0026ldquo;I want to go to Japan!\u0026quot;, about the North-Japanese dialect.\n Work Fugro ICT B.V. \u0026mdash; Helpdesk Employee July 2018\u0026ndash;August 2018 (2 months) in Leidschendam, The Netherlands \nAssisting with general tasks for which the servicedesk is responsible, in addition to developing software (in Python) that enables automating processes within the department at a regional scale. This entailed taking the lead in developing major ICT campaigns including, but not limited to, a region-wide ICT asset replacement campaign and the construction of a comprehensive database cataloging the software and hardware inventory of Fugro NL (The Netherlands, Belgium and Africa) both by person and subsidiary.\n Qualifications Test of English as a Foreign Language (TOEFL iBT) \u0026mdash; 117/120 November 2019.\nJapanese Language Proficiency Test \u0026mdash; N1 Level August 2017, 93rd percentile. Advanced level Japanese language proficiency.\nInternational Baccalaureate \u0026mdash; Higher Level English July 2017, 6/7 points.\nCambridge English Certificate in Advanced English \u0026mdash; Level A (CEFR Level C2) July 2015. Advanced level English mastery.\n Awards Engineering Council \u0026mdash; Society Member of the Month September 2019.\nAwarded by the Engineering Council of the University of Illinois at Urbana-Champaign \u0026ldquo;for hard work and dedication to the College of Engineering and Illinois Space Society.\u0026rdquo;\nEmbassy of Japan in the Netherlands \u0026mdash; 30th Japanese Speaking Contest, Grand Prize March 2017.\nGrand Prize at the 30th Japanese Speaking Contest (five minute speech in Japanese).\n Skills Languages  Dutch: Fluent in word and writing English: Fluent in word and writing Japanese: Fluent in word and writing Arabic: Average in word and writing French: Average in word and writing  Computer skills Basic CSS, XML, Ada 2012\nIntermediate Ruby, OpenFOAM, MOOSE\nExtensive Microsoft Office, Adobe Creative Suite (Photoshop, Illustrator, After Effects), Microsoft Windows, Linux, HTML, JavaScript, C/C++, Haxe, Python, bash, LaTeX.\n"});index.add({'id':2,'href':'/docs/gincy/','title':"Gincy -- Guidance, Navigation \u0026 Control",'content':"Introduction A.\nFirst Section "});index.add({'id':3,'href':'/docs/projects/','title':"Projects",'content':"Projects Reading time: 1 minutes and 58 seconds\nCurrent projects Knifefish  A light-weight framework for robotic electrosurgery  \n Knifefish is a framework for real-time control and simulation of electrosurgical processes, allowing for sensor data processing and feedback control.\nOverview    Language: C++11   License: TBD   Status: In active development  Past/shelved projects Stratagem3D  A light-weight web-based game engine for 3D turn-based strategy games \n Overview    Language: Haxe/Kha   License: TBD   Status: Shelved   Lodestar  C++ digital guidance, navigation and control framework \n Lodestar provides a user friendly platform-agnostic framework for real-time linear control of dynamic systems.\nOverview    Language: C++14   License: MIT   Status: Shelved  The Lodestar framework consists of several templates that allow for control of linear discrete time systems. The following features are implemented:\n Discrete-time linear time invariant systems modeling and control:  Template-based object oriented framework for arbitrary finite dimensional linear systems Linear Quadratic Regulation (LQR) Linear Quadratic Estimation/Classical Kalman Filter (LQE/KF)    Planned features The following capabilities are planned for Lodestar in the near future:\n Continuous to discrete time zero-order hold conversion Recursive algebraic Riccati equation (ARE) solver Recursive Least Squares (RLS) system identification Single-input single-output (SISO) Generalized Predictive Control (GPC) Spatial value functions (SVF) based guidance and path planning [1] Real-time plotting and performance evaluation (impulse, unit step repsonse, Bode/Nyquist plots) frontend Google Protocol Buffers-based message passing interface for real-time logging and command I/O interface for common sensors (e.g., IMUs, barometers, time-of-flight sensors) and servos (e.g., solenoids, brushless DC motors).  Links  Lodestar is powered by:  Eigen: http://eigen.tuxfamily.org/ neither: https://github.com/LoopPerfect/neither   Related projects:  SLICOT (Subroutine Library in Systems and Control Theory): http://slicot.org/ Control Toolbox: https://github.com/ethz-adrl/control-toolbox    References [1] Mettler, B., Dadkhah, N., and Kong, Z. “Agile Autonomous Guidance Using Spatial Value Functions.” Control Engineering Practice, Vol. 18, No. 7, 2010, pp. 773–788. doi:10.1016/j.conengprac.2010.02.013.\n Extendible Orbit System 3D (EOS3D)  Lightweight orbital mechanics calculation and visualization suite based on matplotlib \n Overview    Language: Python   License: MIT   Status: Suspended  The eos3d library is a lightweight orbital mechanics calculation and visualization suite based on matplotlib. It includes orbit visualization, SPACETRACK Two-Line Element retrieval and current satellite position visualization, Solar System orbits and planetary position visualizations and real-time n-body simulations.\nDocumentation The documentation of eos3d-mpl may be downloaded via the following link: documentation.\n"});index.add({'id':4,'href':'/docs/research/','title':"Research",'content':"Research Reading time: 1 minutes and 12 seconds\nActive research areas   Online guaranteed reachability computation for systems experiencing impairment.\n  Autonomous electrosurgery.\n  Talks CSLSC21 I gave a talk on my research on online guaranteed reachability reachable computation at the University of Illinois\u0026rsquo; Coordinated Science Laboratory Student Conference 2021, during the Optimization, Control, and Reinforcement Learning Technical Session held on February 24, 2021:\n  The slides can be accessed here  . A simple code example of the approach presented can be found on Github here .\nCoverage My research on in-flight air density estimation was featured by the Department of Aerospace Engineering at UIUC: Predicting in-flight air density for more accurate landing | Aerospace at Illinois.\nPublications Peer-reviewed publications   El-Kebir, H., \u0026amp; Bentsman, J. (2021). PDE-Based Modeling and Non-collocated Feedback Control of Electrosurgical-Probe/Tissue Interaction. In 2021 American Control Conference (to appear in print).\n  Zhang, S., Bentsman, J., Lou, X., Neuschaefer, C., Lee, Y., \u0026amp; El-Kebir, H. (2020). Multiresolution GPC-Structured Control of a Single-Loop Cold-Flow Chemical Looping Testbed. Energies, 13(7), 1759. https://doi.org/10.3390/en13071759\n  El-Kebir, H., Mazza, M.C., \u0026amp; Liu, J.C.M. (2019). Perceptions of Open Innovation at CERN: An Explorative Study. CERN IdeaSquare Journal of Experimental Innovation, 3(2), 57–61. https://doi.org/10.23726/cij.2019.945\n  Conference papers  El-Kebir, H., \u0026amp; Ornik, M. (2020). In-flight Air Density Estimation and Prediction for Hypersonic Flight Vehicles. In 23rd AIAA International Space Planes and Hypersonic Systems and Technologies Conference. https://doi.org/10.2514/6.2020-2412 (open access)   In the works  El-Kebir, H., \u0026amp; Ornik, M. (2021). Online Inner Approximation of Reachable Sets of Nonlinear Systems with Diminished Control Authority. (preprint to be made available soon).  "});index.add({'id':5,'href':'/posts/signed-distance-functions-collision/','title':"Collisions with Signed Distance Functions",'content':"Reading time: 0 minutes and 1 second.\nIntroduction "});index.add({'id':6,'href':'/posts/signed-distance-functions/','title':"On Signed Distance Functions",'content':"Reading time: 12 minutes and 41 seconds.\nIntroduction Formal Definition In more rigorous terms, signed distance functions (aka SDFs) are defined as functions that satisfy a particular form of the eikonal equation1. The general eikonal equation is of the form:\n$$||\\nabla u(x)|| = \\frac{1}{f(x)},\\quad x \\in \\Omega,$$\nwhere \\(\\Omega\\) is an open set in \\(\\mathbb{R}^n\\), and \\(f(x) : \\mathbb{R}^n \\to \\mathbb{R}\\) is a function with positive values. In physical terms, the solution \\(u(x)\\) to this nonlinear partial differential equation can be interpreted as the shortest time needed to travel from the boundary \\(\\partial\\Omega\\) to \\(x \\in \\Omega\\), with \\(f(x)\\) being the speed at \\(x\\).\nNow, for a signed distance function, the speed will be unity throughout the domain, and \\(x\\) will not be constrained to lie in \\(\\Omega\\). With \\(f(x) \\equiv 1\\), the time to travel from the boundary \\(\\partial\\Omega\\) to any \\(x \\in \\mathbb{R}^n\\) will simply be equal to the shortest distance from \\(x\\) to \\(\\partial\\Omega\\). We may then obtain a signed distance function \\(\\textsf{sdf}(x)\\), provided that the following conditions are satisfied:\n Eikonal equation:  $$\\tag{EE} ||\\nabla\\textsf{sdf}(x)|| = 1,\\quad x \\in \\mathbb{R}^3,$$ Zero distance at the boundary:  $$\\tag{BZ} \\textsf{sdf}(x) = 0,\\quad \\forall \\ x \\in \\partial\\Omega,$$ Inward-facing normal at the boundary:  $$\\tag{IN} \\nabla\\textsf{sdf}(x) = N(x),\\quad \\forall \\ x \\in \\partial\\Omega.$$  If these conditions are satisfied, a function representing the shortest Euclidean distance from \\(x \\in \\mathbb{R}^n\\) to a surface \\(\\partial\\Omega \\subset \\Omega \\subset \\mathbb{R}^n\\) is obtained. This distance is signed, meaning that when \\(x \\in \\Omega\\), \\(\\textsf{sdf}(x)\\) is nonnegative (\\(\\geq 0\\)), while for \\(x \\in \\mathbb{R}^n \\setminus \\Omega\\), \\(\\textsf{sdf}(x)\\) it is negative (\\(\u0026lt; 0\\)).\nTo prove that these conditions produce a distance field (disregarding the sign for now), consider points \\(x, y\\) on a path of steepest-descent, that is a path along gradient \\(\\nabla \\textsf{sdf}\\). As established previously \\(||\\nabla \\textsf{sdf}(x)|| = 1\\) (condition (EE)). The Euclidean distance between these two points will be at most equal to the length of the steepest-descent path, denoted here by \\(\\gamma\\). We find that:\n $$ \\tag{G} ||x - y|| \\leq |\\gamma| = \\left| \\int_\\gamma \\nabla \\textsf{sdf}(\\xi) \\cdot \\mathrm{d}s \\right| = |\\textsf{sdf}(x) - \\textsf{sdf}(y)|. $$\nThen, considering a straight line path from \\(x\\) to \\(y\\), i.e., the shortest path between the two points, denoted here by \\(\\zeta\\), we find the following bound:\n $$ \\tag{Z} \\begin{aligned} ||x - y|| \u0026amp;= |\\zeta| = \\int_\\zeta ||\\nabla \\textsf{sdf}(\\xi)|| \\ ||\\mathrm{d}s|| \\cr \u0026amp;\\geq \\left| \\int_\\zeta \\nabla \\textsf{sdf}(\\xi) \\cdot \\mathrm{d}s \\right| = |\\textsf{sdf}(x) - \\textsf{sdf}(y)|. \\end{aligned} $$\nThe latter inequality is proven straightforwardly by application of the Cauchy\u0026ndash;Schwartz inequality.\n Proof ↕  Consider the Cauchy\u0026ndash;Schwartz inequality as applied to two vectors \\(u, v \\in \\mathbb{R}^n\\):\n $$ \\tag{C\u0026ndash;S} |u \\cdot v| \\leq ||u|| \\ ||v||. $$\nWe found \\(|\\zeta|\\) to be equal to $$ \\int_\\zeta ||\\nabla \\textsf{sdf}(\\xi)|| \\ ||\\mathrm{d}s||. $$\nRecalling the definition of the signed distance function, we have that \\(|\\nabla \\textsf{sdf}(\\xi)| = 1, \\forall \\ \\xi \\in \\mathbb{R}^n \\) (condition (EE)). The following can then be shown by invoking (C\u0026ndash;S):\n$$ \\begin{aligned} \\int_\\zeta ||\\nabla \\textsf{sdf}(\\xi)|| \\ ||\\mathrm{d}s|| \u0026amp;= \\int_\\zeta ||1|| \\ ||\\mathrm{d}s|| \\cr \u0026amp;\\geq \\left|\\int_\\zeta 1 \\cdot \\mathrm{d}s\\right| = \\left|\\int_\\zeta \\nabla \\textsf{sdf}(\\xi) \\cdot \\mathrm{d}s\\right| \\cr \u0026amp;= |\\textsf{sdf}(x) - \\textsf{sdf}(y)|. \\end{aligned} $$\n□\n   Combining inequalities (G) and (Z), we find that the following must hold:\n$$ ||x - y|| = |\\textsf{sdf}(x) - \\textsf{sdf}(y)|. $$\nFinally, from the boundary conditions ((BZ) and (IN)), it is ensured that the function will in fact be a signed distance function for a given object \\(\\Omega\\).\nDifferentiability Since for certain geometries, the derivative at a point where there exist multiple minima (e.g., along the diagonal of a rectangle), is not defined. The points at which this is true are interesting in their own right; as a matter of fact, this set of points is known as the medial axis, or when this set is closed, the cut locus.\nIn the box below, an example of this phenomenon is given for a 2D square SDF.\n Differentiability Example: Square ↕  Let us take one of the signed distance functions presented below to show that these points do indeed exist. Take for example the rectangle SDF, which can be written on one line as follows: $$ \\begin{aligned} \\textsf{sdf}(p, b) \u0026amp;= \\sqrt{\\max(|p_x|-b_x, 0)^2 + \\max(|p_y|-b_y, 0)^2} \\cr \u0026amp;+ \\min(\\max(|p_x|-b_x, |p_y|-b_y), 0). \\end{aligned} $$\nTaking the derivative w.r.t. \\(x\\), where we replaced the absolute value by an equivalent expression (\\(|x| = \\sqrt{x^2}\\) for \\(x \\in \\mathbb{R}\\)), we obtain: $$ \\begin{aligned} \\frac{\\partial \\textsf{sdf}(x, y, w, h)}{\\partial x} \u0026amp;= \\left(\\begin{cases} \\frac{x}{\\sqrt{x^2}} \u0026amp; \\text{if } \\sqrt{x^2} \u0026lt; w \\text{ and } h + \\sqrt{x^2} \\geq w + \\sqrt{y^2} \\cr 0 \u0026amp; \\text{else} \\end{cases}\\right) \\cr \u0026amp;+ \\frac{ \\max(0, -w + \\sqrt{x^2}) \\left(\\begin{cases} \\frac{x}{\\sqrt{x^2}} \u0026amp; \\text{if } \\sqrt{x^2} \u0026gt; w \\cr 0 \u0026amp; \\text{else} \\end{cases}\\right) }{ \\sqrt{\\max(0, -w + \\sqrt{x^2})^2 + \\max(0, -h + \\sqrt{y^2})^2} }, \\end{aligned} $$\nwhere \\(p = [\\begin{smallmatrix} x \u0026amp; y \\end{smallmatrix}]^\\intercal\\) and \\(b = [\\begin{smallmatrix} w \u0026amp; h \\end{smallmatrix}]^\\intercal\\). For ease of exposition, we will consider a particular rectangle, namely a square (\\(w = h = l\\)). After some simplification we find: $$ \\begin{aligned} \\frac{\\partial \\textsf{sdf}(x, y, l)}{\\partial x} \u0026amp;= \\left(\\begin{cases} \\frac{x}{\\sqrt{x^2}} \u0026amp; \\text{if } \\sqrt{y^2} \\leq \\sqrt{x^2} \u0026lt; l \\cr 0 \u0026amp; \\text{else} \\end{cases}\\right) \\cr \u0026amp;+ \\frac{ \\max(0, -l + \\sqrt{x^2}) \\left(\\begin{cases} \\frac{x}{\\sqrt{x^2}} \u0026amp; \\text{if } \\sqrt{x^2} \u0026gt; l \\cr 0 \u0026amp; \\text{else} \\end{cases}\\right) }{ \\sqrt{\\max(0, -l + \\sqrt{x^2})^2 + \\max(0, -l + \\sqrt{y^2})^2} }. \\end{aligned} $$\nNow things start to become a little tricky. To able to make sense of all the \\(\\min\\)s and \\(\\max\\)es, we need to replace them with equivalent expressions in terms of Heaviside unit step functions (\\(H(x)\\)): $$ H(x) \\equiv \\begin{cases} 0 \u0026amp;\\text{for } x \u0026lt; 0 \\cr 1 \u0026amp;\\text{for } x \\geq 0 \\end{cases}. $$ It can readily be shown that: $$\\begin{aligned} \\max(a,b) \u0026amp;= H(a-b)a + [1-H(a-b)] b = H(a-b)a + H(b-a) b, \\cr \\min(a,b) \u0026amp;= H(b-a)a + [1-H(b-a)] b = H(b-a)a + H(a-b) b. \\end{aligned}$$\nWe shall only consider the second term in the partial derivative, since the first term is known to have a limit to zero, and will therefore be determinate within our region of interest. Through substitution of the previous expressions, we obtain: $$\\begin{aligned} D(x, y, l) \u0026amp;= \\frac{D_n(x, l)}{D_d(x,y,l)} \\cr \u0026amp;= \\frac{ x (-l + \\sqrt{x^2}) H(-l + \\sqrt{x^2})^2 }{ \\sqrt{x^2}\\sqrt{(l-\\sqrt{x^2})^2 H(-l + \\sqrt{x^2}) + (l-\\sqrt{y^2})^2 H(-l+\\sqrt{y^2})} }. \\end{aligned}$$\nFor a square, if \\(x=y\\) and \\(|x| \u0026lt; l\\), it is known that there are to edges that lie equally close to \\((x,y)\\). To prove this, we will use L\u0026rsquo;Hôpital\u0026rsquo;s rule to show that now derivative exists for \\(x \u0026lt; l\\). Roughly speaking, L\u0026rsquo;Hôpital\u0026rsquo;s rule states that for a function of the form \\(f(x)/g(x)\\), its limit for \\(x \\rightarrow c\\) exists only if \\(\\lim_{x \\rightarrow c} f^\\prime(x)/g^\\prime(x)\\) exists. In fact, in such a case we will find: $$ \\lim_{x \\rightarrow c} \\frac{f(x)}{g(x)} = \\lim_{x \\rightarrow c} \\frac{f^\\prime(x)}{g^\\prime(x)}. $$\nLet us take \\(f(x) \\equiv D_n(x, l)\\) and \\(g(x) \\equiv D_d(x, x, l)\\). Computing the derivatives, we obtain: $$\\begin{aligned} f^\\prime(x) \u0026amp;= 2 \\sqrt{x^2} \\left(\\sqrt{x^2}-l\\right) \\delta \\left(\\sqrt{x^2}-l\\right) H \\left(\\sqrt{x^2}-l\\right) \\cr \u0026amp;+\\frac{\\left(2 x^2-l \\sqrt{x^2}\\right) H \\left(\\sqrt{x^2}-l\\right)^2}{\\sqrt{x^2}}, \\end{aligned}$$\n$$\\begin{aligned} g^\\prime(x) \u0026amp;= \\frac{\\sqrt{x^2} \\left(\\frac{x \\left(l-\\sqrt{x^2}\\right)^2 \\delta \\left(\\sqrt{x^2}-l\\right)}{\\sqrt{x^2}}+\\frac{2 x \\left(\\sqrt{x^2}-l\\right) H \\left(\\sqrt{x^2}-l\\right)}{\\sqrt{x^2}}\\right)}{2 \\sqrt{2} \\sqrt{\\left(l-\\sqrt{x^2}\\right)^2 H \\left(\\sqrt{x^2}-l\\right)}} \\cr \u0026amp;+\\frac{\\sqrt{2} x \\sqrt{\\left(l-\\sqrt{x^2}\\right)^2 H \\left(\\sqrt{x^2}-l\\right)}}{\\sqrt{x^2}}. \\end{aligned}$$\nWhile \\(f^\\prime(x)\\) appears to hold no singularities at first glance (other than the Dirac delta, which is not triggered since \\(x \u0026lt; l\\)), \\(g^\\prime(x)\\) does have a clear singularity. For its second term, it is clear that the Heaviside function in the denominator will always be zero on the interior, giving cause to a singularity of the form \\(1/\\sqrt{0}\\). With this, we have shown that on the interior diagonals, the derivative SDF of a square shape will indeed not exist. (Since the shape is symmetric in both axes, a derivation in \\(y\\) will yield the exact same result.)\n   Boolean Operations (Combinations) In order to create more complex shapes, it is reasonable to want to run combination operatons on primitives. To get a better handle on what these operations might be, consider the following basic examples:\n Union Difference Intersection  Below, we consider these, and other, operations on two shapes (sets) \\(P\\) and \\(Q\\), resulting in a set \\(R\\). The SDFs belonging to these sets will be subscripted by the name of the set to which they belong. For more information on this topic, see 2, 3.\nUnion $$ R = P \\cup Q \\Leftrightarrow \\textsf{sdf}_R (p) = \\min[\\textsf{sdf}_P (p), \\textsf{sdf}_Q (p)]. $$\nIntersection $$ R = P \\cap Q \\Leftrightarrow \\textsf{sdf}_R (p) = \\max[\\textsf{sdf}_P (p), \\textsf{sdf}_Q (p)]. $$\nNote: This does not produce a proper SDF on the interior.  Difference $$ R = P \\setminus Q \\Leftrightarrow \\textsf{sdf}_R (p) = \\max[\\textsf{sdf}_P (p), -\\textsf{sdf}_Q (p)]. $$\nNote: This does not produce a proper SDF on the interior.  Symmetric Difference Also known as the disjunctive union. Expressed in words, this is the union of the difference of the two sets.\n$$ R = P \\oplus Q = (P \\setminus Q) \\cup (Q \\setminus P) $$ $$\\Leftrightarrow$$ $$ \\textsf{sdf}_R (p) = \\min\\{\\max[\\textsf{sdf}_P (p), -\\textsf{sdf}_Q (p)], \\max[\\textsf{sdf}_Q (p), -\\textsf{sdf}_P (p)]\\}. $$\nNote: This does not produce a proper SDF on the interior.  Complement The complement of an SDF is simply its negative, since its interior then becomes its exterior.\n$$ R = P^\\complement \\Leftrightarrow \\textsf{sdf}_R (p) = -\\textsf{sdf}_P (p). $$\n This does not produce a proper SDF on the interior? ↕  I bet you are puzzled as to why you won\u0026rsquo;t get a proper SDF on using some of the combination operators introduced above. Let\u0026rsquo;s shed some light on this by considering an intersection operator:\n$$ \\textsf{sdf}_R (p) = \\max[\\textsf{sdf}_P (p), \\textsf{sdf}_Q (p)]. $$\nNow, before we get to differentiate, let\u0026rsquo;s try to get rid of that \\(\\max\\) function by introducing Heaviside unit step functions instead:\n$$ \\textsf{sdf}_R (p) = \\textsf{sdf}_P (p) H(\\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p)) + \\textsf{sdf}_Q (p) [1 - H(\\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p))]. $$\nNow, let\u0026rsquo;s take the gradient of this to see if it satisfies the eikonal condition (cond. (EE)):\n$$ \\begin{aligned} [\\nabla \\textsf{sdf}_R (p)]_i \u0026amp;= H_{P-Q} \\partial_i \\textsf{sdf}_P (p) + \\delta_{P-Q} \\textsf{sdf}_P (p) \\partial_i \\textsf{sdf}_{P-Q} (p) \\cr \u0026amp;- \\delta_{P-Q} \\textsf{sdf}_Q (p) \\partial_i \\textsf{sdf}_{P-Q} (p) + (1 - H_{P-Q}) \\partial_i \\textsf{sdf}_Q (p), \\end{aligned} $$\nwhere we have introduced some compact but truthfully nasty shorthand:\n \\(H_{P-Q} \\equiv H(\\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p))\\), \\(\\delta_{P-Q} \\equiv \\delta(\\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p))\\), \\(\\textsf{sdf}_{P-Q}(p) \\equiv \\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p)\\), \\(\\partial_i \\textsf{sdf}(p) \\equiv \\frac{\\partial \\textsf{sdf}(p)}{\\partial p_i}\\).  Let\u0026rsquo;s consider some point \\(p\\) where \\(\\textsf{sdf}_P (p) \\neq \\textsf{sdf}_Q (p)\\) (so as not to deal with the Dirac delta). We can can identify two cases: (1) \\(\\textsf{sdf}_{P-Q} (p) \u0026gt; 0\\), and (2) \\(\\textsf{sdf}_{P-Q} (p) \u0026lt; 0\\). Let\u0026rsquo;s look at the first case:\n$$ [\\nabla \\textsf{sdf}_R (p)]_{i,1} = \\partial_i \\textsf{sdf}_P (p). $$\nHey, now that\u0026rsquo;s cool: the gradient is exactly that of \\(\\textsf{sdf}_P\\), therefore satisfying the eikonal condition. It does not take much reasoning to find out that the same holds for case (2), except this time the gradient will correspond to that of \\(\\textsf{sdf}_Q\\). All things seem to point to a proper SDF \u0026hellip; or is there a catch?\nThe catch There is indeed a catch; we have not considered the case where \\(\\textsf{sdf}_P (p) = \\textsf{sdf}_Q (p)\\). What we get is:\n$$ \\begin{aligned} [\\nabla \\textsf{sdf}_R (p)]_i \u0026amp;= \\partial_i \\textsf{sdf}_P (p) \\cr \u0026amp;+ \\delta_{P-Q} \\partial_i \\textsf{sdf}_{P-Q} (p) \\left( \\textsf{sdf}_P (p) - \\textsf{sdf}_Q (p) \\right), \\end{aligned} $$\nwhere \\(\\delta_{P-Q} = \\delta(0) = \\infty\\). Therefore, the norm of the gradient of this function is indeterminate, let alone equal to 1. For this very reason, we cannot say that the resulting function (after intersection) is a \u0026lsquo;real\u0026rsquo; SDF.\nWhat about the interior? All technicalities aside, it seems at first glance that there are no problems with the distance itself. We haven\u0026rsquo;t taken a look at the interior yet though. While on the interior, the eikonal condition is satisfied, something arguably more important is violated: the shortest distance is not given.\nLet\u0026rsquo;s do a little thought experiment: imagine two circles, with a spacing between the centers. Now take the difference between the two shapes: since we are taking the \\(\\max\\), the distance on the boundary will be given from the farthest circle, instead of the closest circle. Quite obviously, this is not the shortest distance, even though the sign matches. Now this will pose problems when raymarching on the interior, but a similar problem will not be encountered on the exterior, since the distance will monotonically decrease towards the center.\n   Transformations Translation Consider a translation by distance \\(t \\in \\mathbb{R}^3\\). The translated SDF will be of the form:\n$$ \\textsf{sdf}_R (p) = \\textsf{sdf}_P (p - t). $$\nScaling We distinguish uniform and nonuniform scaling. In the first case, the scaling factor is the same across all axes, while in the latter case different scaling factors may be used on different axes.\nUniform Scaling For uniform scaling, consider a scaling factor \\(s \\in \\mathbb{R}_+\\), i.e, the positive orthant of \\(\\mathbb{R}\\). It can be shown that (see \u0026lsquo;Derivations\u0026rsquo; below):\n$$ \\textsf{sdf}_R (p) = \\textsf{sdf}_P (p/s) s . $$\n Example: Uniformly Scaled Sphere ↕  Consider the SDF of a sphere with radius \\(r\\), centered at the origin:\n$$ \\textsf{sdf}(p) = ||p|| - r = \\sqrt{p_x^2 + p_y^2 + p_z^2} - r. $$\nUniform scaling by a factor \\(s \\in \\mathbb{R}_+\\) would yield, as expected:\n$$ \\begin{aligned} \\textsf{sdf}_s (p) \u0026amp;= (||p/s|| - r) s \\cr \u0026amp;= (\\sqrt{p_x^2/s^2 + p_y^2/s^2 + p_z^2/s^2} - r) s \\cr \u0026amp;= (\\sqrt{p_x^2 + p_y^2 + p_z^2}/s - r) s \\cr \u0026amp;= \\sqrt{p_x^2 + p_y^2 + p_z^2} - r s = ||p|| - rs. \\end{aligned} $$\nHere, we simply obtained the SDF of a sphere of radius \\(r^\\prime = r s\\), which is equivalent to scaling the original SDF by a factor of \\(s\\). Clearly, the SDF is proper and the distance is not compressed/dilated. But what about a nonuniform scaling factor \\(s \\in \\mathbb{R}^3\\)?\nTaking the inverse of the transformation matrix \\(S\\), we find that when naively transforming \\(p\\) in the SDF we obtain:\n$$ \\begin{aligned} \\textsf{sdf}_S (p) \u0026amp;= ||p \\oslash s|| - r \\cr \u0026amp;= \\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2} - r, \\end{aligned} $$\nwhere \u0026lsquo;\\(\\oslash\\)\u0026rsquo; denotes componentwise division.\nAt first glance, there don\u0026rsquo;t seem to be any problems with this. Note, however, that the distances obtained in this way do not correspond to the true distances. To see if this indeed is the case, let\u0026rsquo;s verify the eikonal equation condition (cond. (EE)):\n$$ \\begin{aligned} ||\\nabla \\textsf{sdf}_s (p)|| \u0026amp;= ||\\nabla (||p \\oslash s|| - r)|| \\cr \u0026amp;= ||\\nabla (\\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2} - r)|| \\cr \u0026amp;= \\left|\\left| \\begin{bmatrix} \\frac{p_x}{s_x^2} \\cr \\frac{p_y}{s_y^2} \\cr \\frac{p_z}{s_z^2} \\end{bmatrix}/\\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2}\\right|\\right| \\cr \u0026amp;= \\frac{\\sqrt{p_x^2/s_x^4 + p_y^2/s_y^4 + p_z^2/s_z^4}}{\\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2}} \\cr \u0026amp;\\stackrel{?}{\\equiv} 1. \\end{aligned} $$\nIt is straightforward to show, in this case, that this final assertion will only be true when \\(s_x = s_y = s_z = 1\\). This trivially corresponds to uniform scaling with a scaling factor of 1, which constitutes no change from the original SDF. Let us now apply a correction factor \\(c\\) to the SDF, such that we obtain \\(\\textsf{sdf}_{s,c} \\equiv \\textsf{sdf} (p \\oslash s) c\\). Leaving out much of the derivation, which is much the same as what was shown previously, we have:\n$$ \\begin{aligned} ||\\nabla \\textsf{sdf}_{s,c} (p)|| \u0026amp;= ||\\nabla (||p \\oslash s|| - r) c|| \\cr \u0026amp;= ||\\nabla (\\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2} - r) c|| \\cr \u0026amp;= c \\frac{\\sqrt{p_x^2/s_x^4 + p_y^2/s_y^4 + p_z^2/s_z^4}}{\\sqrt{p_x^2/s_x^2 + p_y^2/s_y^2 + p_z^2/s_z^2}} \\cr \u0026amp;\\stackrel{?}{\\equiv} 1. \\end{aligned} $$\nIf we take \\(s_x = s_y = s_z = s\\) and \\(c \\equiv s\\), we can show that:\n$$ \\begin{aligned} ||\\nabla \\textsf{sdf}_s (p)|| \u0026amp;= s \\frac{\\sqrt{p_x^2/s^4 + p_y^2/s^4 + p_z^2/s^4}}{\\sqrt{p_x^2/s^2 + p_y^2/s^2 + p_z^2/s^2}} \\cr \u0026amp;= s \\frac{\\sqrt{s^2}}{\\sqrt{s^4}} = s \\frac{s}{s^2} \\cr \u0026amp;\\equiv 1. \\end{aligned} $$\nWith this, we have shown how proper uniform scaling can be achieved on a sphere.\n   Nonuniform Scaling As discussed in the \u0026lsquo;Derivation\u0026rsquo; box below, there is no straightforward solution to the nonuniform scaling problem that does not violate the eikonal equation condition. The next best \u0026lsquo;solution\u0026rsquo;, would be to obtain some sort of lower distance bound. This provides a straightforward approach to obtaining a lower bound to the scale surface, which will appear correctly when rendered, but does not have a proper SDF. More advantages are listed in the \u0026lsquo;Derivation\u0026rsquo; box below. For a similar discussion, see 4.\nHere, we consider a scaling factor \\(s \\in \\mathbb{R}_+^3\\). As a lower bound, we obtain:\n$$ \\textsf{sdf}_{s,\\text{min}} (p) = \\textsf{sdf} (p \\oslash s) s_\\text{min}, $$\nwhere \\(s_\\text{min}\\) is the smallest element of \\(s\\), and \u0026lsquo;\\(\\oslash\\)\u0026rsquo; denotes componentwise division.\n  Derivation ↕  To be able to perform nonuniform scaling, a first idea would be to see if there is some function \\(c(p)\\) that would allow \\(\\textsf{sdf}_{s,c} (p) \\equiv ||\\nabla [\\textsf{sdf}(p \\oslash s) c(p)]||\\) to satisfy the eikonal equation condition.\nWith this idea in mind, let\u0026rsquo;s apply it to an arbitrary nonuniformly scaled SDF:\n$$ \\begin{aligned} \u0026amp; ||\\nabla \\left[\\textsf{sdf}(p \\oslash s) c(p) \\right]|| = \\cr \u0026amp;\\left[\\left(\\textsf{sdf}(p \\oslash s) \\frac{\\partial c(p)}{\\partial p_x} + \\frac{c(p) \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_x}}{s_x}\\right)^2\\right. \\cr \u0026amp;\\left. + \\left(\\textsf{sdf}(p \\oslash s) \\frac{\\partial c(p)}{\\partial p_y} + \\frac{c(p) \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_y}}{s_y}\\right)^2\\right. \\cr \u0026amp;\\left. + \\left(\\textsf{sdf}(p \\oslash s) \\frac{\\partial c(p)}{\\partial p_z} + \\frac{c(p) \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_z}}{s_z}\\right)^2\\right]^{1/2}. \\end{aligned} $$\nTo satisfy the eikonal equation, our initial goal is to try to achieve the following:\n$$ \\textsf{sdf}(p \\oslash s) \\frac{\\partial c(p)}{\\partial p_j} + \\frac{c(p) \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_j}}{s_j} = \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_j}. $$\nIf this is achieved, we know for a fact that \\(||\\nabla \\left[\\textsf{sdf}(p \\oslash s) c(p) \\right]|| = ||\\nabla \\textsf{sdf}(p)|| \\equiv 1 \\).\nUniform scaling For uniform scaling, as seen before, where \\(s_i = s\\), the conditions required to obtain this result are:\n Uniform scaling: \\(s_x = s_y = s_z = s\\), A constant \\(c\\): \\(\\frac{\\partial c(p)}{\\partial p_j} \\equiv 0\\), \\(c \\equiv s\\) to obtain \\((c/s) \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_j} = \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_j}\\).  Nonuniform scaling Rewriting the equation given above, we obtain:\n$$ \\textsf{sdf}(p \\oslash s) \\frac{\\partial c(p)}{\\partial p_j} + (c(p)/s_j - 1) \\frac{\\partial\\textsf{sdf}(p \\oslash s)}{\\partial p_j} = 0. $$\nThis boils down to solving the following system of equations:\n$$ \\begin{aligned} \\frac{\\partial c(p)}{\\partial p_j} \u0026amp;= q_j(p) - \\frac{q_j(p)}{s_j} c(p), \\quad j=1\\ldots3 \\cr \\text{where } q_j(p) \u0026amp;\\equiv \\textsf{sdf}(p \\oslash s) \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_j}. \\end{aligned} $$\nThis time, we cannot get away with taking a constant \\(c\\), since this would not satisfy the differential equation for all \\(j\\). Even for some sort of discontinuous \\(c\\), this effect can\u0026rsquo;t be achieved, since there is is no indication as to what condition \\(j\\) is being evaluated based only on \\(p\\).\nA lower bound for nonuniform scaling In practical situations, it is useful to at least have a lower bound of the SDF. Since the SDF is identically zero at the surface, and the sign is preserved even when scaling, only the interior and exterior distances will be smaller than they would actually be. This is a useful property in cases such as raymarching, where overshoot is not desirable.\nLet\u0026rsquo;s study if such a lower bound can actually be computed. The new eikonal equation for an pseudo-SDF that performs nonuniform scaling but corrects using the smallest scaling factor, takes the form of:\n$$ \\begin{aligned} \u0026amp; ||\\nabla \\left[\\textsf{sdf}(p \\oslash s) s_\\text{min} \\right]|| = \\cr \u0026amp;\\left[\\left( \\frac{s_\\text{min} \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_x}}{s_x} \\right)^2 \\right. \\cr \u0026amp;\\left. + \\left( \\frac{s_\\text{min} \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_y}}{s_y} \\right)^2 \\right. \\cr \u0026amp;\\left. + \\left( \\frac{s_\\text{min} \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_z}}{s_z} \\right)^2 \\right]^{1/2}, \\end{aligned} $$\nwhere \\(s_\\text{min} \\equiv \\min(s)\\).\nConsidering the indivual elements, it is clear that:\n$$ \\left( \\frac{s_\\text{min} \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_x}}{s_x} \\right)^2 \\leq \\left( \\frac{\\partial \\textsf{sdf}(p \\oslash s)}{\\partial p_x} \\right)^2, \\quad j = 1\\ldots 3, $$\nwhich follows from the fact that \\(s_\\text{min}/s_j \\leq 1\\). Therefore, \\(||\\nabla \\left[\\textsf{sdf}(p \\oslash s) s_\\text{min} \\right]|| \\leq 1\\), which means that the distance between points will be lower than the actual distance (see the discussion of the eikonal equation above).\nWith this, we can use the following equation as a lower-bound SDF-like function for nonuniform scaling:\n$$ \\textsf{sdf}_{s,\\text{min}} (p) = \\textsf{sdf} (p \\oslash s) s_\\text{min}. $$\n   List of 2D Functions The following signed distance functions assume that the primitive is centered at the origin, unless stated otherwise. Most of these functions are adapted from Inigo Quilez\u0026rsquo;s excellent 2D SDF functions article, while others are derived from other sources in the literature.\nPoint $$ \\textsf{sdf}(p) = ||p|| = \\sqrt{p_x^2 + p_y^2}. $$\n  $$ $$ Implementation GLSL  float point(vec2 p) { return length(p); }   Haxe  static public inline function point(p:Vec2):FFloat { return p.length; }    Circle A circle simply offsets the distance to a point by a radius \\(r\\), as follows:\n$$ \\textsf{sdf}(p, r) = ||p|| - r = \\sqrt{p_x^2 + p_y^2} - r. $$\nImplementation GLSL  float circle(vec2 p, float r) { return length(p) - r; }   Haxe  static public inline function circle(p:Vec2, r:FFloat):FFloat { return p.length - r; }    Rectangle For a rectangle, consider a 2D vector \\(d\\) consisting of the width (in \\(x\\)-direction), and the height. Operators with the subscript \\(i\\) notation (e.g., \\(\\textrm{abs}_i\\)) will act on a vector in a component-wise fashion (similar to Einstein\u0026rsquo;s tensor notation); see 5 for more information.\n$$\\begin{aligned} d(b) \u0026amp;= \\textrm{abs}_i(p)-b, \\cr \\textsf{sdf}(p, d(b)) \u0026amp;= ||\\max_i(d, 0)|| + \\min(\\max(d_x, d_y), 0). \\end{aligned}$$\nImplementation GLSL  float rectangle(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }   Haxe  static public function rectangle(p:Vec2, b:Vec2):FFloat { final d = p.abs().sub(b); return d.max(0).length + Math.min(Math.max(d.x, d.y), 0); }    Rounded Rectangle The rounded rectangle follows a similar construction method to the rectangle, although the individual corners are rounded independently, producing a different result compared to the rectangle with uniform rounding applied.\n  Wikipedia. Eikonal equation. \u0026#x21a9;\u0026#xfe0e;\n Efi Fogel, Ron Wein, Baruch Zukerman, and Dan Halperin (2005). Boolean Set-Operations on \\(X\\)-monotone Curve Bounded Point-Sets. \u0026#x21a9;\u0026#xfe0e;\n CGAL, 2D Regularized Boolean Set-Operations. \u0026#x21a9;\u0026#xfe0e;\n Jamie Wong (2016). Ray Marching and Signed Distance Functions. \u0026#x21a9;\u0026#xfe0e;\n Wikipedia. Pointwise: Componentwise operations \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':7,'href':'/posts/','title':"Blog",'content':""});index.add({'id':8,'href':'/tags/mathematics/','title':"mathematics",'content':""});index.add({'id':9,'href':'/tags/physics/','title':"physics",'content':""});index.add({'id':10,'href':'/tags/SDF/','title':"SDF",'content':""});index.add({'id':11,'href':'/tags/','title':"Tags",'content':""});index.add({'id':12,'href':'/docs/gincy/StateSpace/','title':"State Space",'content':"Introduction to State Space   $$ \\mathbf{\\Sigma}_{\\mathrm{CTLTI}} = \\begin{cases} \\dot{\\mathbf{x}}(t) \u0026= \\mathbf{A} \\mathbf{x}(t) + \\mathbf{B} \\mathbf{u}(t) \\\\ \\mathbf{y}(t) \u0026= \\mathbf{C} \\mathbf{x}(t) + \\mathbf{D} \\mathbf{u}(t) \\end{cases} $$ $$ \\mathbf{\\Sigma}_{\\mathrm{DTLTI}} = \\begin{cases} \\mathbf{x}(k+1) \u0026= \\mathbf{\\Phi} \\mathbf{x}(k) + \\mathbf{\\Gamma} \\mathbf{u}(k) \\\\ \\mathbf{y}(k) \u0026= \\mathbf{C} \\mathbf{x}(k) + \\mathbf{D} \\mathbf{u}(k) \\end{cases} $$   graph LR Guidance -- Navigation Navigation -- Control Control -- Guidance Navigation -- Guidance Fig. 1: Basic flowdown of GN\u0026C "});index.add({'id':13,'href':'/posts/3/','title':"3rd",'content':"3 "});index.add({'id':14,'href':'/categories/','title':"Categories",'content':""});index.add({'id':15,'href':'/docs/','title':"Docs",'content':""});index.add({'id':16,'href':'/','title':"Home",'content':"Welcome! My name is Hamza El-Kebir, I am a doctoral candidate in aerospace engineering, passionate about all things related to control theory.\n 日本語版の方がいい？ Liever in het Nederlands?\n   News  I gave a talk at the 2021 UIUC CSL Student Conference titled Guaranteed Reachability for Systems with Impaired Dynamics.  About me in short I enjoy tackling problems and exploring new grounds in the field of control engineering. Besides theoretical study, I am passionate about applying control theory to practical problems.\nI like to travel and read, and I am a space history enthusiast. In my pastime I enjoy hiking and practicing jiujitsu.\n What\u0026rsquo;s on this site? Besides my curriculum vitae, you will find a list of my open source projects, as well as documentation (more on that on the left side of this page). In the near future, I will start a blog series exploring the expansive world of controls and its (unexpected) applications.   Social media   GitHub (@helkebir)  LinkedIn  Facebook  "});})();